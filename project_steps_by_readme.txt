Шаг 1. Подготовка окружения
1. Установить PostgreSQL и создать базу данных `check` c пользователем `postgres` / пароль `postgres` (или скорректировать настройки в `mysite/settings.py`).
2. Установить Python 3.10+ и виртуальное окружение.
3. В корне проекта создать и активировать виртуальное окружение, установить зависимости: Django, psycopg2 (при необходимости).

Пример команд (Windows, PowerShell):
python -m venv venv
.\venv\Scripts\activate
pip install django psycopg2-binary

Создание БД (в psql, если нужно):
CREATE DATABASE check;
CREATE USER postgres WITH PASSWORD 'postgres';
GRANT ALL PRIVILEGES ON DATABASE check TO postgres;

Шаг 2. Модуль 1 — база данных
1. На основе описания предметной области (Прил_1) спроектировать таблицы: категории, товары, производители, поставщики, единицы измерения, пользователи, роли, статусы заказов, пункты выдачи, заказы, товары в заказах.
2. Нормализовать схему до 3НФ: вынести повторяющиеся сущности (категории, роли, статусы и т.п.) в отдельные таблицы, определить первичные ключи (обычно surrogate PK — integer/serial) и внешние ключи.
3. В СУБД PostgreSQL создать таблицы с нужными полями и связями (либо через SQL-скрипт, либо через визуальный конструктор).
4. Заполнить таблицы начальными данными из архивов import (Прил_2): категории, товары, производители, поставщики, пользователи с ролями, статусы заказов, пункты выдачи и т.п.
5. Построить ER-диаграмму (таблицы + связи), экспортировать в PDF и сохранить в материалы проекта.

Шаг 3. Модуль 2 — подключение БД и базовый интерфейс
1. Создать Django‑проект (`mysite`) и приложение (`shoe_store`), подключить PostgreSQL в `mysite/settings.py` (DATABASES).
2. В `shoe_store/models.py` описать модели, строго соответствующие уже существующим таблицам БД:
   - указать `db_table` для каждой модели;
   - поставить `managed = False`, чтобы Django не пытался менять структуру;
   - определить все `ForeignKey` в соответствии с внешними ключами в БД.
3. Проверить, что `INSTALLED_APPS` содержит `shoe_store`, запустить `python manage.py check` — убедиться, что системных ошибок нет.
4. Настроить статику в `mysite/settings.py`:
   - `STATIC_URL = 'static/'`;
   - `STATICFILES_DIRS = [BASE_DIR / 'shoe_store']`, чтобы брать картинки из папки приложения.
5. Создать базовый шаблон `base.html` с логотипом, заголовком окна, блоком для контента и отображением ФИО пользователя / статуса гостя, согласно стилю из README (логотип, шрифт, цвета).

Пример команд:
django-admin startproject mysite .
python manage.py startapp shoe_store
python manage.py check
python manage.py migrate
python manage.py runserver

Шаг 4. Авторизация и роли
1. В `shoe_store/models.py` использовать таблицу `users` и `roles`: `Users` c FK на `Roles`.
2. В `shoe_store/views.py` реализовать `login_view`:
   - GET: показать форму входа (`login.html`), очистить сессию;
   - POST: по email+паролю найти пользователя в `Users`;
   - при успехе: сохранить в сессию `user_fio` и `user_role` (строка роли из таблицы `roles`), перенаправить на список товаров;
   - при ошибке: вернуть `login.html` с сообщением об ошибке.
3. В `login.html` сделать поля логина/пароля и кнопку «Войти», а также ссылку «Войти как гость», ведущую на страницу списка товаров без авторизации.
4. В `base.html` выводить:
   - если в сессии есть `user_fio` — показывать ФИО и ссылку «Выход»;
   - иначе — показывать «Гость» и ссылку «Войти».

Шаг 5. Отображение списка товаров для всех ролей
1. В `shoe_store/views.py` реализовать `products_list`:
   - загрузка товаров из модели `Products` с `select_related` всех нужных связей (производитель, поставщик, категория, единица);
   - вычисление `final_price` для каждого товара с учётом скидки;
   - получение из сессии роли пользователя (`user_role`).
2. Логика по ролям:
   - Гость: только просмотр списка товаров без поиска, фильтрации и сортировки;
   - Клиент: просмотр с возможностью поиска/фильтрации/сортировки (по требованиям модуля 3);
   - Менеджер: как у клиента + доступ к просмотру заказов;
   - Администратор: как у менеджера + функции добавления/редактирования/удаления товаров.
3. В `products.html` вывести:
{% if product.photo %}
                    <img src="{% static 'img/'|add:product.photo %}" alt="Фото товара" width="100">
                {% else %}
                    <img src="{% static 'img/picture.png' %}" alt="Фото товара" width="100">
                {% endif %}
   - список товаров с фото (или заглушкой `picture.png`), названием, категорией, описанием, производителем, поставщиком, ценой (и итоговой ценой при скидке), единицей измерения и количеством;
   - подсветку:
     - при `discount > 15` фон карточки `#2E8B57`;
     - при `amount == 0` фон голубой;
     - при наличии скидки — зачёркнутая старая цена (красным) и новая — рядом (чёрным).

Полезные команды для отладки:
python manage.py shell
python manage.py dbshell
python manage.py check

Шаг 6. Поиск, сортировка и фильтры (модуль 3)
1. В `products_list` добавить:
   - строку поиска `search`, которая фильтрует по нескольким текстовым полям (`product_name`, `description`, категория, производитель, поставщик) через `Q`‑объекты;
   - сортировку по количеству на складе (`amount`) по параметру `sort` (`asc` / `desc`);
   - фильтрацию по поставщику (`provider`) с возможностью выбора «Все поставщики».
2. Убедиться, что поиск, фильтрация и сортировка могут комбинироваться и применяются одновременно.
3. Для гостя выключить применение фильтров/сортировок, оставив только базовый список.

Шаг 7. Просмотр заказов
1. В `urls.py` приложения добавить маршрут `orders/` на `orders_list`.
2. В `views.py` реализовать `orders_list`:
   - доступен ролям «Менеджер» и «Администратор»; для остальных — вывести понятное сообщение об отсутствии прав;
   - загрузить заказы (`Orders`) с `select_related` на пользователя, пункт выдачи и статус заказа;
   - передать их в шаблон `orders.html`.
3. В `orders.html` отрисовать таблицу с основными полями заказа (ID, даты, пункт выдачи, клиент, статус) и кнопкой «Назад».
4. В `products.html` вывести ссылки на страницу заказов для ролей менеджера и администратора.

Проверка URL‑конфигурации:
python manage.py show_urls   (если установлен django-extensions)

Шаг 8. CRUD для товаров (только администратор)
1. В `forms.py` создать `ProductsForm` по модели `Products` со всеми необходимыми полями (включая путь к фото).
2. В `urls.py` добавить маршруты:
   - `products/add/` → создание товара;
   - `products/<pk>/edit/` → редактирование;
   - `products/<pk>/delete/` → удаление.
3. В `views.py` реализовать:
   - `product_create`: только для администратора, форма по `ProductsForm`, после успешного сохранения — редирект на список товаров;
   - `product_update`: только для администратора, та же форма, но с `instance`;
   - `product_delete`: только для администратора; перед удалением проверять, есть ли записи в `Products_in_orders` для данного товара — если есть, не удалять и вывести сообщение.
4. В `products.html` для администратора добавить ссылки «Редактировать» и «Удалить» на соответствующие маршруты.
5. В шаблонах форм (`product_form.html`, `product_confirm_delete.html`) предусмотреть удобный интерфейс и кнопки «Назад»/«Отмена».

Шаг 9. Работа с изображениями (для администратора)
1. В модели `Products` поле `photo` использовать как путь к файлу в файловой системе.
2. При создании/редактировании товара:
   - организовать загрузку файла (можно через отдельное представление с `FileField`/`ImageField` и Pillow, если это требуется в условиях экзамена);
   - ограничить размер изображения до 300x200 пикселей (обработать через Pillow при сохранении);
   - сохранить файл в каталог с приложением (например, `shoe_store/img/products/`) и записать относительный путь в поле `photo`.
3. При замене фото — удалять старый файл с диска, если он больше не используется.

Шаг 10. Удаление товаров и защита от ошибок
1. Перед удалением товара проверять наличие записей в `Products_in_orders`; при наличии — не удалять, а показывать пользователю сообщение об ошибке.
2. Оборачивать потенциально опасные операции (поиск по БД, парсинг параметров) в обработчики исключений, выводить понятные сообщения пользователю (без падения сервера).
3. В шаблонах и представлениях проверять наличие данных (например, пустые списки товаров/заказов) и выводить дружелюбные сообщения.

Шаг 11. Тестирование и финальная проверка
1. Запустить сервер разработки, пройти по всем основным сценариям:
   - вход как гость, клиент, менеджер, администратор;
   - просмотр списка товаров для каждой роли;
   - поиск, сортировка, фильтрация;
   - просмотр заказов менеджером и администратором;
   - добавление, редактирование и удаление товара (включая случай, когда товар участвует в заказе).
2. Убедиться в отсутствии ошибок в консоли Django (`python manage.py check`) и в браузере (500/404).
3. Сделать скриншоты основных окон и сценариев для отчёта (.docx).

Команды перед финальной сдачей:
python manage.py check
python manage.py migrate
python manage.py runserver
pip freeze > requirements.txt

Шаг 12. Документация
1. Собрать в одну папку:
   - ER‑диаграмму (PDF);
   - SQL‑скрипт создания БД или экспорт схемы;
   - блок‑схему алгоритма работы приложения (PDF);
   - отчёт по тестированию со скриншотами (DOCX);
   - README с кратким описанием проекта и инструкцией по запуску.
2. Проверить, что все ссылки в интерфейсе рабочие, а поведение ролей строго соответствует ТЗ из README.

